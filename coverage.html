
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/apetsko/gophkeeper/config/config.go (92.0%)</option>
				
				<option value="file1">github.com/apetsko/gophkeeper/internal/constants/constants.go (100.0%)</option>
				
				<option value="file2">github.com/apetsko/gophkeeper/internal/crypto/envelope.go (77.5%)</option>
				
				<option value="file3">github.com/apetsko/gophkeeper/internal/crypto/keys.go (82.9%)</option>
				
				<option value="file4">github.com/apetsko/gophkeeper/internal/server/grpc/handlers/data_delete.go (100.0%)</option>
				
				<option value="file5">github.com/apetsko/gophkeeper/internal/server/grpc/handlers/data_list.go (100.0%)</option>
				
				<option value="file6">github.com/apetsko/gophkeeper/internal/server/grpc/handlers/data_save.go (93.9%)</option>
				
				<option value="file7">github.com/apetsko/gophkeeper/internal/server/grpc/handlers/data_view.go (83.0%)</option>
				
				<option value="file8">github.com/apetsko/gophkeeper/internal/server/grpc/handlers/login.go (94.1%)</option>
				
				<option value="file9">github.com/apetsko/gophkeeper/internal/server/grpc/handlers/ping.go (100.0%)</option>
				
				<option value="file10">github.com/apetsko/gophkeeper/internal/server/grpc/handlers/server_admin.go (100.0%)</option>
				
				<option value="file11">github.com/apetsko/gophkeeper/internal/server/grpc/handlers/signup.go (88.2%)</option>
				
				<option value="file12">github.com/apetsko/gophkeeper/internal/server/grpc/server.go (46.6%)</option>
				
				<option value="file13">github.com/apetsko/gophkeeper/internal/server/http/server.go (67.6%)</option>
				
				<option value="file14">github.com/apetsko/gophkeeper/internal/storage/postgres.go (82.4%)</option>
				
				<option value="file15">github.com/apetsko/gophkeeper/internal/storage/s3.go (79.3%)</option>
				
				<option value="file16">github.com/apetsko/gophkeeper/pkg/jwt/jwt.go (100.0%)</option>
				
				<option value="file17">github.com/apetsko/gophkeeper/pkg/logging/logger.go (93.9%)</option>
				
				<option value="file18">github.com/apetsko/gophkeeper/pkg/password/password.go (100.0%)</option>
				
				<option value="file19">github.com/apetsko/gophkeeper/pkg/version/version.go (0.0%)</option>
				
				<option value="file20">github.com/apetsko/gophkeeper/utils/utils.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package config provides configuration loading and validation for the GophKeeper application.
//
// It supports loading configuration from environment variables or a YAML file, and validates required fields.
// The Config struct holds all application settings, including database, server, JWT, S3, and TLS options.
// The New function loads and validates the configuration, decoding the server encryption key as needed.
package config

import (
        "encoding/hex"
        "errors"
        "flag"
        "fmt"
        "log/slog"
        "os"

        "github.com/apetsko/gophkeeper/internal/constants"
        "github.com/apetsko/gophkeeper/utils"
        "github.com/caarlos0/env/v11"
        "gopkg.in/yaml.v3"
)

// Config holds all application configuration settings, loaded from environment variables or a YAML file.
type Config struct {
        // ConfigFile is the path to the YAML configuration file.
        ConfigFile string `env:"CONFIG_FILE" yaml:"CONFIG_FILE"`
        // DatabaseDSN is the Data Source Name for connecting to the Postgres database.
        DatabaseDSN string `env:"DATABASE_DSN" yaml:"DATABASE_DSN" validate:"required"`
        // GRPCAddress is the address for the gRPC server to listen on.
        GRPCAddress string `env:"GRPC_ADDRESS" yaml:"GRPC_ADDRESS" validate:"required"`
        // HTTPAddress is the address for the HTTP server to listen on.
        HTTPAddress string `env:"HTTP_ADDRESS" yaml:"HTTP_ADDRESS" validate:"required"`
        // StrServerEK is the hex-encoded server encryption key.
        StrServerEK string `env:"SERVER_ENCRYPTION_KEY" yaml:"SERVER_ENCRYPTION_KEY" validate:"required"`
        // ServerEK is the decoded server encryption key as a byte slice.
        ServerEK []byte
        // JWT holds JWT-related configuration.
        JWT JWTConfig `yaml:"JWT"`
        // S3Config holds S3/MinIO-related configuration.
        S3Config S3Config `yaml:"S3"`
        // TLSConfig holds TLS/HTTPS-related configuration.
        TLSConfig TLSConfig `yaml:"TLS"`
}

// JWTConfig contains settings for JWT authentication.
type JWTConfig struct {
        // Secret is the secret key for signing JWT tokens.
        Secret string `env:"JWT_SECRET" yaml:"JWT_SECRET" validate:"required"`
}

// S3Config contains settings for S3/MinIO object storage.
type S3Config struct {
        // AccessKey is the S3 access key.
        AccessKey string `env:"S3_ACCESS_KEY" yaml:"S3_ACCESS_KEY" validate:"required"`
        // SecretKey is the S3 secret key.
        SecretKey string `env:"S3_SECRET_KEY" yaml:"S3_SECRET_KEY" validate:"required"`
        // Bucket is the S3 bucket name.
        Bucket string `env:"S3_BUCKET" yaml:"S3_BUCKET" validate:"required"`
        // Endpoint is the S3 service endpoint.
        Endpoint string `env:"S3_ENDPOINT" yaml:"S3_ENDPOINT" validate:"required"`
}

// TLSConfig contains settings for enabling HTTPS/TLS.
type TLSConfig struct {
        // EnableHTTPS enables HTTPS if set to true.
        EnableHTTPS bool `env:"TLS_ENABLE_HTTPS" yaml:"TLS_ENABLE_HTTPS"`
        // CertPath is the path to the TLS certificate file.
        CertPath string `env:"TLS_CERT_PATH" yaml:"TLS_CERT_PATH"`
        // KeyPath is the path to the TLS private key file.
        KeyPath string `env:"TLS_KEY_PATH" yaml:"TLS_KEY_PATH"`
}

// New loads and validates the application configuration from a YAML file or environment variables.
// It decodes the server encryption key and returns a Config instance.
func New() (*Config, error) <span class="cov10" title="6">{
        var cfg Config

        fs := flag.NewFlagSet("config", flag.ContinueOnError)
        fs.StringVar(&amp;cfg.ConfigFile, "f", "", "config.yaml or config.yml")
        _ = fs.Parse(os.Args[1:]) // Не паникуем на ошибке парсинга

        // file or env
        if cfg.ConfigFile != "" </span><span class="cov4" title="2">{
                slog.Info("Using config file: " + cfg.ConfigFile)
                if err := cfg.readConfigFile(); err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to load config from file: %w", err)
                }</span>
        } else<span class="cov7" title="4"> {
                if err := env.Parse(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to load environment: %w", err)
                }</span>
        }

        // Validate the loaded configuration
        <span class="cov9" title="5">if err := utils.ValidateStruct(cfg); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov7" title="4">serverKey, errDecode := hex.DecodeString(cfg.StrServerEK)
        if errDecode != nil </span><span class="cov1" title="1">{
                return nil, errDecode
        }</span>

        <span class="cov6" title="3">if len(serverKey) != constants.KeyLength </span><span class="cov1" title="1">{
                return nil, errors.New("server encryption key must be 32 bytes")
        }</span>

        <span class="cov4" title="2">cfg.ServerEK = serverKey

        return &amp;cfg, nil</span>
}

// readConfigFile loads configuration from the specified YAML file into the Config struct.
func (cfg *Config) readConfigFile() error <span class="cov4" title="2">{
        b, err := os.ReadFile(cfg.ConfigFile)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov1" title="1">if err := yaml.Unmarshal(b, &amp;cfg); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package constants defines common constants and utility functions used across the GophKeeper application.
package constants

import pbc "github.com/apetsko/gophkeeper/protogen/api/proto/v1/common"

// mdKey is a custom type for metadata keys used in context.
type mdKey string

// contextKey is a custom type for context keys.
type contextKey string

const (
        // JWT is the context key for storing JWT tokens in metadata.
        JWT mdKey = "jwt"
        // UserID is the context key for storing user ID in context.
        UserID contextKey = "userID"
)

const (
        // BankCard represents the data type for bank card information.
        BankCard string = "bank_card"
        // Credentials represents the data type for user credentials.
        Credentials string = "credentials"
        // BinaryData represents the data type for binary data.
        BinaryData string = "binary_data"
)

const (
        // KeyLength is the required length (in bytes) for encryption keys.
        KeyLength int = 32
        // Mem is the memory parameter for cryptographic operations (e.g., Argon2).
        Mem uint32 = 64 * 1024
        // Threads is the number of threads for cryptographic operations.
        Threads uint8 = 4
)

// MapDataTypeToString maps a protobuf DataType to its string representation.
//
// Returns the corresponding string constant for the given DataType.
// If the type is unknown, returns "unknown".
func MapDataTypeToString(dt pbc.DataType) string <span class="cov10" title="9">{
        switch dt </span>{
        case pbc.DataType_DATA_TYPE_BANK_CARD:<span class="cov5" title="3">
                return BankCard</span>
        case pbc.DataType_DATA_TYPE_CREDENTIALS:<span class="cov3" title="2">
                return Credentials</span>
        case pbc.DataType_DATA_TYPE_BINARY_DATA:<span class="cov5" title="3">
                return BinaryData</span>
        default:<span class="cov1" title="1">
                return "unknown"</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package crypto provides cryptographic utilities for data encryption and decryption using envelope encryption.
package crypto

import (
        "context"
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "fmt"

        "github.com/apetsko/gophkeeper/internal/constants"
        "github.com/apetsko/gophkeeper/models"
)

// IEnvelope defines the interface for envelope encryption and decryption of user data.
//
//go:generate mockery --dir ./internal/crypto --name=IEnvelopeStorage --output=.../mocks/ --case=underscore
type IEnvelope interface {
        // EncryptUserData encrypts the given data with a randomly generated DEK, which is itself encrypted with the master key.
        EncryptUserData(ctx context.Context, masterKey []byte, data []byte) (*models.EncryptedData, error)
        // DecryptUserData decrypts the user data using the provided master key.
        DecryptUserData(ctx context.Context, userData models.DBUserData, masterKey []byte) ([]byte, error)
}

// EnvelopStorage defines the interface for persisting user data.
type EnvelopStorage interface {
        // SaveUserData saves the user data and returns the new record's ID.
        SaveUserData(ctx context.Context, userData *models.DBUserData) (int, error)
}

// Envelope implements the IEnvelope interface and provides envelope encryption logic.
type Envelope struct {
        storage EnvelopStorage
}

// NewEnvelope creates a new Envelope with the given storage backend.
func NewEnvelope(storage EnvelopStorage) *Envelope <span class="cov10" title="3">{
        return &amp;Envelope{
                storage: storage,
        }
}</span>

// EncryptUserData encrypts the provided data using a randomly generated DEK, which is then encrypted with the master key.
// Returns the encrypted data, encrypted DEK, and their nonces.
func (e *Envelope) EncryptUserData(
        ctx context.Context,
        masterKey []byte,
        data []byte,
) (*models.EncryptedData, error) <span class="cov10" title="3">{
        // 1. Генерируем случайный DEK
        dek := make([]byte, constants.KeyLength)
        if _, err := rand.Read(dek); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate DEK: %w", err)
        }</span>

        // 2. Шифруем данные DEK
        <span class="cov10" title="3">block, err := aes.NewCipher(dek)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create cipher for DEK: %w", err)
        }</span>
        <span class="cov10" title="3">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create GCM for DEK: %w", err)
        }</span>
        <span class="cov10" title="3">dataNonce := make([]byte, gcm.NonceSize())
        if _, err := rand.Read(dataNonce); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error generate dataNonce: %w", err)
        }</span>

        <span class="cov10" title="3">encryptedData := gcm.Seal(nil, dataNonce, data, nil)

        // 3. Шифруем DEK Master Key
        mkBlock, _ := aes.NewCipher(masterKey)
        mkGCM, _ := cipher.NewGCM(mkBlock)
        dekNonce := make([]byte, mkGCM.NonceSize())
        if _, err := rand.Read(dekNonce); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error generate dekNonce: %w", err)
        }</span>

        <span class="cov10" title="3">encryptedDEK := mkGCM.Seal(nil, dekNonce, dek, nil)

        return &amp;models.EncryptedData{
                EncryptedData: encryptedData,
                DataNonce:     dataNonce,
                EncryptedDek:  encryptedDEK,
                DekNonce:      dekNonce,
        }, nil</span>
}

// DecryptUserData decrypts the encrypted user data using the master key.
// It first decrypts the DEK, then uses it to decrypt the actual data.
func (e *Envelope) DecryptUserData(
        ctx context.Context,
        userData models.DBUserData,
        masterKey []byte,
) ([]byte, error) <span class="cov10" title="3">{
        // 1. Расшифровываем DEK с помощью Master Key
        mkBlock, err := aes.NewCipher(masterKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create AES cipher for master key: %w", err)
        }</span>

        <span class="cov10" title="3">mkGCM, err := cipher.NewGCM(mkBlock)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create GCM for master key: %w", err)
        }</span>

        <span class="cov10" title="3">dek, err := mkGCM.Open(nil, userData.DekNonce, userData.EncryptedDek, nil)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to decrypt DEK: %w", err)
        }</span>

        // 2. Расшифровываем данные с помощью DEK
        <span class="cov6" title="2">block, err := aes.NewCipher(dek)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create AES cipher for DEK: %w", err)
        }</span>

        <span class="cov6" title="2">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create GCM for DEK: %w", err)
        }</span>

        <span class="cov6" title="2">decryptData, err := gcm.Open(nil, userData.DataNonce, userData.EncryptedData, nil)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to decrypt data: %w", err)
        }</span>

        <span class="cov1" title="1">return decryptData, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package crypto provides cryptographic utilities for data encryption and decryption using envelope encryption.
package crypto

import (
        "context"
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "crypto/subtle"
        "errors"

        "github.com/apetsko/gophkeeper/internal/constants"
        "github.com/apetsko/gophkeeper/models"
        "golang.org/x/crypto/argon2"
)

// KeyManagerInterface defines methods for managing user master keys.
//
//go:generate mockery --dir ./internal/crypto --name=KeyManagerInterface --output=../mocks/ --case=underscore
type KeyManagerInterface interface {
        GetMasterKey(ctx context.Context, userID int) ([]byte, error)
        GetOrCreateMasterKey(ctx context.Context, userID int, userPassword string, userSalt []byte) ([]byte, error)
}

// Убедимся, что KeyManager реализует интерфейс
var _ KeyManagerInterface = (*KeyManager)(nil)

// KeyStorage defines the interface for persisting and retrieving encrypted master keys.
type KeyStorage interface {
        // GetMasterKey fetches the encrypted master key for the user.
        GetMasterKey(ctx context.Context, userID int) (*models.EncryptedMK, error)
        // SaveMasterKey stores the encrypted master key and its nonce for the user.
        SaveMasterKey(ctx context.Context, userID int, encryptedMK, nonce []byte) (int, error)
}

// KeyManager implements KeyManagerInterface and handles master key encryption and decryption.
type KeyManager struct {
        storage             KeyStorage
        serverEncryptionKey []byte
}

// NewKeyManager creates a new KeyManager with the given storage and server encryption key.
func NewKeyManager(
        storage KeyStorage,
        serverEncryptionKey []byte,
) *KeyManager <span class="cov10" title="5">{
        return &amp;KeyManager{
                storage:             storage,
                serverEncryptionKey: serverEncryptionKey,
        }
}</span>

// GetMasterKey retrieves and decrypts the user's master key using the server encryption key.
func (m *KeyManager) GetMasterKey(ctx context.Context, userID int) ([]byte, error) <span class="cov4" title="2">{
        encryptedMK, err := m.storage.GetMasterKey(ctx, userID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">block, _ := aes.NewCipher(m.serverEncryptionKey)
        gcm, _ := cipher.NewGCM(block)

        mk, err := gcm.Open(nil, encryptedMK.Nonce, encryptedMK.EncryptedMK, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return mk, nil</span>
}

// GetOrCreateMasterKey retrieves the user's master key if it exists and validates the password,
// or generates and stores a new master key if not found.
func (m *KeyManager) GetOrCreateMasterKey(
        ctx context.Context,
        userID int,
        userPassword string,
        userSalt []byte,
) ([]byte, error) <span class="cov7" title="3">{
        encryptedMK, err := m.storage.GetMasterKey(ctx, userID)
        if err != nil </span><span class="cov4" title="2">{
                if errors.Is(err, models.ErrMasterKeyNotFound) </span><span class="cov4" title="2">{
                        return m.generateAndStoreMasterKey(ctx, userID, userPassword, userSalt)
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov1" title="1">block, _ := aes.NewCipher(m.serverEncryptionKey)
        gcm, _ := cipher.NewGCM(block)

        mk, err := gcm.Open(nil, encryptedMK.Nonce, encryptedMK.EncryptedMK, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">computedMK := argon2.IDKey([]byte(userPassword), userSalt, 3, constants.Mem, constants.Threads, uint32(constants.KeyLength))
        if subtle.ConstantTimeCompare(mk, computedMK) != 1 </span><span class="cov1" title="1">{
                return nil, errors.New("invalid password")
        }</span>

        <span class="cov0" title="0">return mk, nil</span>
}

// generateAndStoreMasterKey generates a new master key from the user's password and salt,
// encrypts it with the server key, stores it, and returns the plaintext master key.
func (m *KeyManager) generateAndStoreMasterKey(
        ctx context.Context,
        userID int,
        userPassword string,
        userSalt []byte,
) ([]byte, error) <span class="cov4" title="2">{
        mk := argon2.IDKey([]byte(userPassword), userSalt, 3, constants.Mem, constants.Threads, uint32(constants.KeyLength))

        block, errBlock := aes.NewCipher(m.serverEncryptionKey)
        if errBlock != nil </span><span class="cov0" title="0">{
                return nil, errBlock
        }</span>

        <span class="cov4" title="2">gcm, _ := cipher.NewGCM(block)
        nonce := make([]byte, gcm.NonceSize())
        if _, err := rand.Read(nonce); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("error generate nonce")
        }</span>

        <span class="cov4" title="2">encryptedMK := gcm.Seal(nil, nonce, mk, nil)

        _, err := m.storage.SaveMasterKey(ctx, userID, encryptedMK, nonce)

        return mk, err</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package handlers provides gRPC server handlers for managing user data operations,
// including creation, retrieval, update, and deletion of user records.
package handlers

import (
        "context"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        "github.com/apetsko/gophkeeper/internal/constants"
        pbrpc "github.com/apetsko/gophkeeper/protogen/api/proto/v1/rpc"
)

// DataDelete handles the gRPC request to delete a user's data record.
//
// This method checks user authorization, verifies ownership of the data record,
// and deletes the record from storage if permitted.
//
// Parameters:
//   - ctx: The gRPC context.
//   - in: The DataDeleteRequest message with the data record ID.
//
// Returns:
//   - *pbrpc.DataDeleteResponse: Success message if deletion is successful.
//   - error: A gRPC error if the user is not authorized or an internal error occurs.
func (s *ServerAdmin) DataDelete(ctx context.Context, in *pbrpc.DataDeleteRequest) (*pbrpc.DataDeleteResponse, error) <span class="cov10" title="5">{
        userID, ok := ctx.Value(constants.UserID).(int)
        if !ok </span><span class="cov1" title="1">{
                return nil, status.Errorf(codes.InvalidArgument, "не удалось получить UserID")
        }</span>

        <span class="cov8" title="4">userData, err := s.Storage.GetUserData(ctx, int(in.GetId()))
        if err != nil </span><span class="cov1" title="1">{
                return nil, status.Errorf(codes.Internal, "ошибка получения данных")
        }</span>

        <span class="cov7" title="3">if userData.UserID != userID </span><span class="cov1" title="1">{
                return nil, status.Errorf(codes.PermissionDenied, "нельзя удалить запись, она не ваша")
        }</span>

        <span class="cov4" title="2">errDelete := s.Storage.DeleteUserData(ctx, int(in.GetId()))
        if errDelete != nil </span><span class="cov1" title="1">{
                return nil, status.Errorf(codes.Internal, "ошибка удаления данных")
        }</span>

        <span class="cov1" title="1">return &amp;pbrpc.DataDeleteResponse{
                Message: "ok",
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package handlers provides gRPC server handlers for managing user data operations,
// including creation, retrieval, update, and deletion of user records.
package handlers

import (
        "context"
        "log/slog"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/encoding/protojson"

        "github.com/apetsko/gophkeeper/internal/constants"
        pbmodels "github.com/apetsko/gophkeeper/protogen/api/proto/v1/models"
        pbrpc "github.com/apetsko/gophkeeper/protogen/api/proto/v1/rpc"
)

// DataView handles the gRPC request to retrieve a specific user data record by its ID.
//
// This method checks user authorization, fetches and decrypts the data (including files from S3 if needed),
// parses the data according to its type, and returns it in the response.
//
// Parameters:
// - ctx: The gRPC context.
// - in: The DataViewRequest message with the data record ID.
//
// Returns:
// - *pbrpc.DataViewResponse: The requested data record.
// - error: An error if access is denied or retrieval fails.
func (s *ServerAdmin) DataList(ctx context.Context, in *pbrpc.DataListRequest) (*pbrpc.DataListResponse, error) <span class="cov10" title="5">{
        userID, ok := ctx.Value(constants.UserID).(int)
        if !ok </span><span class="cov4" title="2">{
                return nil, status.Errorf(codes.InvalidArgument, "не удалось получить UserID")
        }</span>

        <span class="cov7" title="3">userDataList, err := s.Storage.GetUserDataList(ctx, userID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, status.Errorf(codes.Internal, "ошибка получения данных: %v", err)
        }</span>

        <span class="cov4" title="2">var records []*pbmodels.Record
        for _, data := range userDataList </span><span class="cov8" title="4">{
                // Преобразуем строку Meta (в формате JSON) в pbmodels.Meta
                var meta pbmodels.Meta
                if errUnmarshal := protojson.Unmarshal([]byte(data.Meta), &amp;meta); errUnmarshal != nil </span><span class="cov1" title="1">{
                        slog.Error("failed to unmarshal meta: " + errUnmarshal.Error())
                        continue</span>
                }

                <span class="cov7" title="3">record := &amp;pbmodels.Record{
                        Id:        int32(data.ID),
                        Type:      data.Type,
                        Meta:      &amp;meta,
                        CreatedAt: data.CreatedAt.Format("02.01.2006 15:04"),
                }
                records = append(records, record)</span>
        }

        <span class="cov4" title="2">return &amp;pbrpc.DataListResponse{
                Records: records,
                Count:   int32(len(records)), // Или общее количество в базе, если есть пагинация
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package handlers provides gRPC server handlers for managing user data operations,
// including creation, retrieval, update, and deletion of user records.
package handlers

import (
        "context"
        "fmt"
        "log/slog"
        "time"

        "github.com/apetsko/gophkeeper/internal/constants"
        "github.com/apetsko/gophkeeper/models"
        pbc "github.com/apetsko/gophkeeper/protogen/api/proto/v1/common"
        pbmodels "github.com/apetsko/gophkeeper/protogen/api/proto/v1/models"
        pbrpc "github.com/apetsko/gophkeeper/protogen/api/proto/v1/rpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/encoding/protojson"
        "google.golang.org/protobuf/proto"
)

// DataSave handles the gRPC request to save user data.
//
// This method validates the request, retrieves the user's master key, encrypts the data,
// and stores it in the database or S3 depending on the data type.
//
// Parameters:
// - ctx: The gRPC context.
// - in: The DataSaveRequest message containing user data.
//
// Returns:
// - *pbrpc.DataSaveResponse: A response indicating success.
// - error: An error if validation or storage fails.
func (s *ServerAdmin) DataSave(ctx context.Context, in *pbrpc.DataSaveRequest) (*pbrpc.DataSaveResponse, error) <span class="cov10" title="14">{
        userID, ok := ctx.Value(constants.UserID).(int)
        if !ok </span><span class="cov1" title="1">{
                return nil, status.Errorf(codes.InvalidArgument, "не удалось получить UserID")
        }</span>

        // Валидация типа данных
        <span class="cov9" title="13">if in.Type == pbc.DataType_DATA_TYPE_UNSPECIFIED </span><span class="cov1" title="1">{
                return nil, status.Errorf(codes.InvalidArgument, "тип данных не указан")
        }</span>

        // TODO: переделать на потокобезопасную in memory мапу
        <span class="cov9" title="12">encryptedMK, err := s.KeyManager.GetMasterKey(ctx, userID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("error get encryptedMK: %v", err)
        }</span>

        // Обработка данных в зависимости от типа
        <span class="cov9" title="11">switch in.Type </span>{
        case pbc.DataType_DATA_TYPE_BANK_CARD:<span class="cov5" title="4">
                bankCard := in.GetBankCard()
                if bankCard == nil </span><span class="cov1" title="1">{
                        return nil, status.Errorf(codes.InvalidArgument, "отсутствуют данные банковской карты")
                }</span>

                <span class="cov4" title="3">err := s.saveUserData(ctx, userID, in.Type, encryptedMK, bankCard, in.Meta)
                if err != nil </span><span class="cov3" title="2">{
                        return nil, err
                }</span>

        case pbc.DataType_DATA_TYPE_CREDENTIALS:<span class="cov3" title="2">
                creds := in.GetCredentials()
                if creds == nil </span><span class="cov1" title="1">{
                        return nil, status.Errorf(codes.InvalidArgument, "отсутствуют учетные данные")
                }</span>
                <span class="cov1" title="1">err := s.saveUserData(ctx, userID, in.Type, encryptedMK, creds, in.Meta)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

        case pbc.DataType_DATA_TYPE_BINARY_DATA:<span class="cov6" title="5">
                file := in.GetBinaryData()
                if file == nil </span><span class="cov1" title="1">{
                        return nil, status.Errorf(codes.InvalidArgument, "отсутствуют данные файла")
                }</span>

                // Шифруем содержимое файла
                <span class="cov5" title="4">encryptedData, err := s.Envelope.EncryptUserData(ctx, encryptedMK, file.Data)
                if err != nil </span><span class="cov1" title="1">{
                        slog.Error("failed to encrypt binary data", "error", err)
                        return nil, fmt.Errorf("failed to encrypt binary data: %v", err)
                }</span>

                // Генерируем уникальное имя файла
                <span class="cov4" title="3">objectName := fmt.Sprintf("%d-%s", time.Now().UnixNano(), file.Name)

                // Загружаем в S3
                s3UploadData := &amp;models.S3UploadData{
                        ObjectName:  objectName,
                        MetaContent: in.Meta.Content,
                        FileName:    file.Name,
                        FileType:    file.Type,
                }
                _, err = s.StorageS3.Upload(ctx, encryptedData.EncryptedData, s3UploadData)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to upload file to MinIO: %v", err)
                }</span>

                // Сохраняем метаданные в БД
                <span class="cov3" title="2">saveUserData := &amp;models.DBUserData{
                        UserID:        userID,
                        Type:          constants.MapDataTypeToString(in.Type),
                        MinioObjectID: objectName,
                        DataNonce:     encryptedData.DataNonce,
                        EncryptedDek:  encryptedData.EncryptedDek,
                        DekNonce:      encryptedData.DekNonce,
                        Meta:          protojson.Format(in.Meta),
                }
                _, err = s.Storage.SaveUserData(ctx, saveUserData)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>

        default:<span class="cov0" title="0">
                return nil, status.Errorf(codes.Unimplemented, "неподдерживаемый тип данных: %v", in.Type)</span>
        }

        <span class="cov4" title="3">return &amp;pbrpc.DataSaveResponse{
                Message: fmt.Sprintf("данные типа %s успешно сохранены", in.Type.String()),
        }, nil</span>
}

func (s *ServerAdmin) saveUserData(
        ctx context.Context,
        userID int,
        dataType pbc.DataType,
        encryptedMK []byte,
        data proto.Message,
        meta *pbmodels.Meta,
) error <span class="cov5" title="4">{
        // Маршал protobuf
        serialized, err := proto.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("serialize error: %v", err)
        }</span>

        // Шифруем данные
        <span class="cov5" title="4">encryptedData, err := s.Envelope.EncryptUserData(ctx, encryptedMK, serialized)
        if err != nil </span><span class="cov1" title="1">{
                slog.Error("failed to crypt data: " + err.Error())
                return fmt.Errorf("encrypt error: %v", err)
        }</span>

        // Сохраняем в БД
        <span class="cov4" title="3">saveUserData := &amp;models.DBUserData{
                UserID:        userID,
                Type:          constants.MapDataTypeToString(dataType),
                EncryptedData: encryptedData.EncryptedData,
                DataNonce:     encryptedData.DataNonce,
                EncryptedDek:  encryptedData.EncryptedDek,
                DekNonce:      encryptedData.DekNonce,
                Meta:          protojson.Format(meta),
        }
        _, err = s.Storage.SaveUserData(ctx, saveUserData)
        return err</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Package handlers provides gRPC server handlers for managing user data operations,
// including creation, retrieval, update, and deletion of user records.
package handlers

import (
        "context"
        "fmt"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/encoding/protojson"
        "google.golang.org/protobuf/proto"

        "github.com/apetsko/gophkeeper/internal/constants"
        pbc "github.com/apetsko/gophkeeper/protogen/api/proto/v1/common"
        "github.com/apetsko/gophkeeper/protogen/api/proto/v1/models"
        pbrpc "github.com/apetsko/gophkeeper/protogen/api/proto/v1/rpc"
)

var stringToDataType = map[string]pbc.DataType{
        "bank_card":   pbc.DataType_DATA_TYPE_BANK_CARD,
        "credentials": pbc.DataType_DATA_TYPE_CREDENTIALS,
        "binary_data": pbc.DataType_DATA_TYPE_BINARY_DATA,
}

// DataView handles the gRPC request to retrieve a specific user data record by its ID.
//
// This method checks user authorization, fetches the encrypted data from the database or S3 (for binary files),
// decrypts the data using the user's master key, parses it according to its type (bank card, credentials, or binary data),
// and returns the result in the response.
//
// Parameters:
//   - ctx: The gRPC context.
//   - in: The DataViewRequest message containing the record ID.
//
// Returns:
//   - *pbrpc.DataViewResponse: The requested user data record.
//   - error: A gRPC error if access is denied or an internal error occurs.
func (s *ServerAdmin) DataView(ctx context.Context, in *pbrpc.DataViewRequest) (*pbrpc.DataViewResponse, error) <span class="cov10" title="8">{
        userID, ok := ctx.Value(constants.UserID).(int)
        if !ok </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.InvalidArgument, "не удалось получить UserID")
        }</span>

        <span class="cov10" title="8">userData, err := s.Storage.GetUserData(ctx, int(in.GetId()))
        if err != nil </span><span class="cov1" title="1">{
                return nil, status.Errorf(codes.Internal, "ошибка получения данных")
        }</span>

        // Проверка прав доступа
        <span class="cov9" title="7">if userData.UserID != userID </span><span class="cov1" title="1">{
                return nil, status.Errorf(codes.PermissionDenied, "нет доступа к запрошенным данным")
        }</span>

        <span class="cov8" title="6">encryptedMK, err := s.KeyManager.GetMasterKey(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error get encryptedMK: %v", err)
        }</span>

        <span class="cov8" title="6">var decryptData []byte
        var dataType pbc.DataType
        var file models.File

        switch userData.Type </span>{
        case constants.BinaryData:<span class="cov1" title="1">
                // Обработка бинарных данных (скачивание из MinIO)
                fileData, fileInfo, errGetObject := s.StorageS3.GetObject(
                        ctx,
                        userData.MinioObjectID,
                )
                if errGetObject != nil </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.Internal, "ошибка получения файла из хранилища: %v", errGetObject)
                }</span>

                <span class="cov1" title="1">userData.EncryptedData = fileData

                decryptData, err = s.Envelope.DecryptUserData(ctx, *userData, encryptedMK)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.Internal, "ошибка расшифровки файла: %v", err)
                }</span>

                <span class="cov1" title="1">originalName := fileInfo.UserMetadata["original-name"]
                if originalName == "" </span><span class="cov0" title="0">{
                        originalName = userData.MinioObjectID
                }</span>

                <span class="cov1" title="1">file = models.File{
                        Name: originalName,
                        Data: decryptData,
                        Size: int32(len(decryptData)),
                        Type: fileInfo.ContentType,
                }

                dataType = pbc.DataType_DATA_TYPE_BINARY_DATA</span>
        default:<span class="cov7" title="5">
                decryptData, err = s.Envelope.DecryptUserData(ctx, *userData, encryptedMK)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, status.Errorf(codes.Internal, "ошибка расшифровки данных")
                }</span>

                <span class="cov7" title="4">var ok bool
                dataType, ok = stringToDataType[userData.Type]
                if !ok </span><span class="cov1" title="1">{
                        return nil, status.Errorf(codes.InvalidArgument, "неподдерживаемый тип данных: %s", userData.Type)
                }</span>
        }

        <span class="cov7" title="4">var meta models.Meta
        if errUnmarshal := protojson.Unmarshal([]byte(userData.Meta), &amp;meta); errUnmarshal != nil </span><span class="cov1" title="1">{
                return nil, status.Errorf(codes.Internal, "ошибка парсинга Meta JSON: %v", errUnmarshal)
        }</span>

        // 4. Создаем базовый ответ
        <span class="cov5" title="3">response := &amp;pbrpc.DataViewResponse{
                Type: dataType,
                Meta: &amp;meta,
        }

        // 5. Парсим данные в зависимости от типа
        if err := parseData(response, dataType, decryptData, &amp;file); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="3">return response, nil</span>
}

func parseData(r *pbrpc.DataViewResponse, dataType pbc.DataType, decryptData []byte, file *models.File) error <span class="cov5" title="3">{
        switch dataType </span>{
        case pbc.DataType_DATA_TYPE_BANK_CARD:<span class="cov1" title="1">
                var card models.BankCard
                if errUnmarshal := proto.Unmarshal(decryptData, &amp;card); errUnmarshal != nil </span><span class="cov0" title="0">{
                        return status.Errorf(codes.Internal, "ошибка парсинга карты")
                }</span>
                <span class="cov1" title="1">r.Data = &amp;pbrpc.DataViewResponse_BankCard{BankCard: &amp;card}</span>

        case pbc.DataType_DATA_TYPE_CREDENTIALS:<span class="cov1" title="1">
                var credentials models.Credentials
                if errUnmarshal := proto.Unmarshal(decryptData, &amp;credentials); errUnmarshal != nil </span><span class="cov0" title="0">{
                        return status.Errorf(codes.Internal, "ошибка парсинга учетных данных")
                }</span>
                <span class="cov1" title="1">r.Data = &amp;pbrpc.DataViewResponse_Credentials{Credentials: &amp;credentials}</span>

        case pbc.DataType_DATA_TYPE_BINARY_DATA:<span class="cov1" title="1">
                r.Data = &amp;pbrpc.DataViewResponse_BinaryData{BinaryData: file}</span>

        default:<span class="cov0" title="0">
                return status.Errorf(codes.InvalidArgument, "неподдерживаемый тип данных")</span>
        }
        <span class="cov5" title="3">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Package handlers provides gRPC server handlers for managing user data operations,
// including creation, retrieval, update, and deletion of user records.
package handlers

import (
        "context"
        "errors"
        "fmt"
        "log/slog"

        "github.com/apetsko/gophkeeper/models"
        "github.com/apetsko/gophkeeper/pkg/jwt"
        "github.com/apetsko/gophkeeper/pkg/password"
        pbrpcu "github.com/apetsko/gophkeeper/protogen/api/proto/v1/rpc/user"
)

// Login handles the gRPC request for user authentication.
//
// This method validates the username and password, checks credentials against the database,
// generates a JWT token upon successful authentication, and ensures the user's master key exists.
//
// Parameters:
// - ctx: The gRPC context.
// - in: The LoginRequest message with user credentials.
//
// Returns:
// - *pbrpcu.LoginResponse: User details and authentication token.
// - error: An error if authentication fails.
func (s *ServerAdmin) Login(ctx context.Context, in *pbrpcu.LoginRequest) (*pbrpcu.LoginResponse, error) <span class="cov10" title="7">{
        if len(in.Username) &lt; 3 || len(in.Password) &lt; 8 </span><span class="cov4" title="2">{
                return nil, fmt.Errorf("username and password must be at least 3 and 8 characters long")
        }</span>

        <span class="cov8" title="5">user, err := s.Storage.GetUser(ctx, in.Username)
        if err != nil </span><span class="cov4" title="2">{
                if errors.Is(err, models.ErrUserNotFound) </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("invalid credentials")
                }</span>
                <span class="cov1" title="1">return nil, fmt.Errorf("failed to get user: %w", err)</span>
        }

        <span class="cov6" title="3">if !password.CheckPasswordHash(in.Password, user.PasswordHash) </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("invalid credentials")
        }</span>

        <span class="cov4" title="2">token, err := jwt.GenerateJWT(user.ID, user.Username, s.JWTConfig.Secret)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate token: %w", err)
        }</span>

        // TODO: нужно записать в потокобезопасную мапу в памяти
        <span class="cov4" title="2">_, errMasterKey := s.KeyManager.GetOrCreateMasterKey(
                ctx,
                user.ID,
                in.Password,
                nil,
        )

        if errMasterKey != nil </span><span class="cov1" title="1">{
                slog.Error("failed to generate encrypted master key: " + errMasterKey.Error())

                return nil, errors.New("failed to generate encrypted master key")
        }</span>

        <span class="cov1" title="1">return &amp;pbrpcu.LoginResponse{
                Id:       int32(user.ID),
                Username: user.Username,
                Token:    token,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package handlers provides gRPC server handlers for managing user data operations,
// including creation, retrieval, update, and deletion of user records.
package handlers

import (
        "context"

        pbrpc "github.com/apetsko/gophkeeper/protogen/api/proto/v1/rpc"
)

// Ping handles a health check request for the gRPC service.
//
// This method is used to verify that the server is alive and responding to requests.
// It does not perform any logic and always returns an empty successful response.
//
// Parameters:
// - ctx: The gRPC context (not used).
// - in: The PingRequest message (not used).
//
// Returns:
// - *pbrpc.PingResponse: An empty response indicating success.
// - error: Always nil.
func (s *ServerAdmin) Ping(_ context.Context, _ *pbrpc.PingRequest) (*pbrpc.PingResponse, error) <span class="cov10" title="2">{
        return &amp;pbrpc.PingResponse{
                Message: "pong",
        }, nil
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package handlers

import (
        "github.com/apetsko/gophkeeper/config"
        "github.com/apetsko/gophkeeper/internal/crypto"
        "github.com/apetsko/gophkeeper/internal/storage"
)

type ServerAdmin struct {
        Storage    storage.IStorage
        StorageS3  storage.S3Client
        JWTConfig  config.JWTConfig
        Envelope   crypto.IEnvelope
        KeyManager crypto.KeyManagerInterface
}

func NewServerAdmin(
        storage storage.IStorage,
        storageS3 storage.S3Client,
        jwtConfig config.JWTConfig,
        envelope crypto.IEnvelope,
        keyManager crypto.KeyManagerInterface,
) *ServerAdmin <span class="cov10" title="3">{
        return &amp;ServerAdmin{
                Storage:    storage,
                StorageS3:  storageS3,
                JWTConfig:  jwtConfig,
                Envelope:   envelope,
                KeyManager: keyManager,
        }
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// Package handlers provides gRPC server handlers for managing user data operations,
// including creation, retrieval, update, and deletion of user records.
package handlers

import (
        "context"
        "errors"
        "fmt"
        "log/slog"

        "github.com/apetsko/gophkeeper/models"
        "github.com/apetsko/gophkeeper/pkg/jwt"
        "github.com/apetsko/gophkeeper/pkg/password"
        pbrpcu "github.com/apetsko/gophkeeper/protogen/api/proto/v1/rpc/user"
)

// Signup handles the gRPC request for user registration.
//
// This method validates the username and password, hashes the password,
// creates a new user record in the database, and generates a JWT token for the user.
//
// Parameters:
//   - ctx: The gRPC context.
//   - in: The SignupRequest message with user credentials.
//
// Returns:
//   - *pbrpcu.SignupResponse: User details and authentication token.
//   - error: An error if registration fails.
func (s *ServerAdmin) Signup(ctx context.Context, in *pbrpcu.SignupRequest) (*pbrpcu.SignupResponse, error) <span class="cov10" title="5">{
        if len(in.Username) &lt; 3 || len(in.Password) &lt; 8 </span><span class="cov4" title="2">{
                return nil, fmt.Errorf("username and password must be at least 3 and 8 characters long")
        }</span>

        <span class="cov7" title="3">hash, err := password.HashPassword(in.Password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to hash password: %w", err)
        }</span>

        <span class="cov7" title="3">user := models.UserEntry{
                Username:     in.Username,
                PasswordHash: hash,
        }

        userID, err := s.Storage.AddUser(ctx, &amp;user)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to create user: %w", err)
        }</span>

        <span class="cov4" title="2">token, err := jwt.GenerateJWT(userID, in.Username, s.JWTConfig.Secret)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate token: %w", err)
        }</span>

        // TODO: нужно записать в потокобезопасную мапу в памяти
        <span class="cov4" title="2">_, errMasterKey := s.KeyManager.GetOrCreateMasterKey(
                ctx,
                userID,
                in.Password,
                nil,
        )

        if errMasterKey != nil </span><span class="cov1" title="1">{
                slog.Error("failed to generate encrypted master key: " + errMasterKey.Error())

                return nil, errors.New("failed to generate encrypted master key")
        }</span>

        <span class="cov1" title="1">return &amp;pbrpcu.SignupResponse{
                Id:       int32(user.ID),
                Username: user.Username,
                Token:    token,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Package grpc provides the gRPC server implementation for the GophKeeper service.
//
// This package sets up the gRPC server, configures authentication middleware,
// registers service handlers, and manages server lifecycle and TLS settings.
package grpc

import (
        "context"
        "errors"
        "fmt"
        "log/slog"
        "net"

        "github.com/golang-jwt/jwt/v5"
        grpcLogging "github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/logging"
        "golang.org/x/sync/errgroup"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/credentials"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/reflection"
        "google.golang.org/grpc/status"

        "github.com/apetsko/gophkeeper/config"
        "github.com/apetsko/gophkeeper/internal/constants"
        "github.com/apetsko/gophkeeper/internal/server/grpc/handlers"
        "github.com/apetsko/gophkeeper/pkg/logging"
        pb "github.com/apetsko/gophkeeper/protogen/api/proto/v1"
        pbrpc "github.com/apetsko/gophkeeper/protogen/api/proto/v1/rpc"
        pbrpcu "github.com/apetsko/gophkeeper/protogen/api/proto/v1/rpc/user"
)

// GRPCHandler implements the gRPC server interface for the GophKeeper service.
//
// This struct embeds ServerAdmin to delegate business logic for user and data operations.
// It provides gRPC method handlers for health checks, user authentication, registration,
// and CRUD operations on user data records.
type GRPCHandler struct {
        pb.UnimplementedGophKeeperServer
        *handlers.ServerAdmin
}

// NewGRPCHandler creates a new GRPCHandler instance.
//
// Parameters:
//   - admin: Pointer to ServerAdmin containing business logic.
//
// Returns:
//   - pb.GophKeeperServer: The gRPC server handler.
func NewGRPCHandler(admin *handlers.ServerAdmin) pb.GophKeeperServer <span class="cov10" title="3">{
        return &amp;GRPCHandler{
                ServerAdmin: admin,
        }
}</span>

// Ping handles a health check request for the gRPC service.
//
// This method verifies that the server is alive and responding to requests.
// It delegates the call to ServerAdmin and always returns a successful response.
//
// Parameters:
//   - ctx: The gRPC context.
//   - in: The PingRequest message.
//
// Returns:
//   - *pbrpc.PingResponse: An empty response indicating success.
//   - error: Always nil.
func (s *GRPCHandler) Ping(ctx context.Context, in *pbrpc.PingRequest) (*pbrpc.PingResponse, error) <span class="cov6" title="2">{
        return s.ServerAdmin.Ping(ctx, in)
}</span>

// Login handles the gRPC request for user authentication.
//
// This method validates the username and password, checks credentials against the database,
// generates a JWT token upon successful authentication, and ensures the user's master key exists.
//
// Parameters:
//   - ctx: The gRPC context.
//   - in: The LoginRequest message with user credentials.
//
// Returns:
//   - *pbrpcu.LoginResponse: User details and authentication token.
//   - error: An error if authentication fails.
func (s *GRPCHandler) Login(ctx context.Context, in *pbrpcu.LoginRequest) (*pbrpcu.LoginResponse, error) <span class="cov0" title="0">{
        return s.ServerAdmin.Login(ctx, in)
}</span>

func (s *GRPCHandler) Signup(ctx context.Context, in *pbrpcu.SignupRequest) (*pbrpcu.SignupResponse, error) <span class="cov0" title="0">{
        return s.ServerAdmin.Signup(ctx, in)
}</span>

// DataList handles the gRPC request to list all user data records.
//
// This method checks user authorization and retrieves a list of data records
// associated with the authenticated user.
//
// Parameters:
//   - ctx: The gRPC context.
//   - in: The DataListRequest message.
//
// Returns:
//   - *pbrpc.DataListResponse: List of user data records.
//   - error: A gRPC error if access is denied or an internal error occurs.
func (s *GRPCHandler) DataList(ctx context.Context, in *pbrpc.DataListRequest) (*pbrpc.DataListResponse, error) <span class="cov1" title="1">{
        return s.ServerAdmin.DataList(ctx, in)
}</span>

// DataSave handles the gRPC request to create or update a user data record.
//
// This method checks user authorization, validates the input, encrypts the data,
// and saves it to the database or storage.
//
// Parameters:
//   - ctx: The gRPC context.
//   - in: The DataSaveRequest message with data to save.
//
// Returns:
//   - *pbrpc.DataSaveResponse: Confirmation of save operation.
//   - error: A gRPC error if access is denied or an internal error occurs.
func (s *GRPCHandler) DataSave(ctx context.Context, in *pbrpc.DataSaveRequest) (*pbrpc.DataSaveResponse, error) <span class="cov0" title="0">{
        return s.ServerAdmin.DataSave(ctx, in)
}</span>

// DataDelete handles the gRPC request to delete a user's data record.
//
// This method checks user authorization, verifies ownership of the data record,
// and deletes the record from storage if permitted.
//
// Parameters:
//   - ctx: The gRPC context.
//   - in: The DataDeleteRequest message with the data record ID.
//
// Returns:
//   - *pbrpc.DataDeleteResponse: Success message if deletion is successful.
//   - error: A gRPC error if the user is not authorized or an internal error occurs.
func (s *GRPCHandler) DataDelete(ctx context.Context, in *pbrpc.DataDeleteRequest) (*pbrpc.DataDeleteResponse, error) <span class="cov0" title="0">{
        return s.ServerAdmin.DataDelete(ctx, in)
}</span>

// DataView handles the gRPC request to retrieve a specific user data record by its ID.
//
// This method checks user authorization, fetches the encrypted data from storage,
// decrypts it, and returns the result in the response.
//
// Parameters:
//   - ctx: The gRPC context.
//   - in: The DataViewRequest message containing the record ID.
//
// Returns:
//   - *pbrpc.DataViewResponse: The requested user data record.
//   - error: A gRPC error if access is denied or an internal error occurs.
func (s *GRPCHandler) DataView(ctx context.Context, in *pbrpc.DataViewRequest) (*pbrpc.DataViewResponse, error) <span class="cov0" title="0">{
        return s.ServerAdmin.DataView(ctx, in)
}</span>

// RunGRPC starts the gRPC server for the GophKeeper service.
//
// This function configures the gRPC server with optional TLS, authentication middleware,
// logging interceptors, and registers the service handlers. It listens on the configured
// address and manages the server lifecycle using an error group.
//
// Parameters:
//   - cfg: Pointer to the application configuration.
//   - sa: Pointer to ServerAdmin containing business logic.
//   - log: Logger instance for server logging.
//
// Returns:
//   - *grpc.Server: The running gRPC server instance.
//   - error: An error if the server fails to start.
func RunGRPC(cfg *config.Config, sa *handlers.ServerAdmin, log *logging.Logger) (*grpc.Server, error) <span class="cov1" title="1">{
        lis, err := net.Listen("tcp", cfg.GRPCAddress)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to listen on %s: %v", cfg.GRPCAddress, err)
        }</span>

        <span class="cov1" title="1">var opts []grpc.ServerOption

        if cfg.TLSConfig.EnableHTTPS </span><span class="cov0" title="0">{
                creds, err := credentials.NewServerTLSFromFile(cfg.TLSConfig.CertPath, cfg.TLSConfig.KeyPath)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("failed to load TLS credentials: %v", err)
                }</span>
                <span class="cov0" title="0">opts = append(opts, grpc.Creds(creds))</span>
        }

        <span class="cov1" title="1">opts = append(opts, grpc.ChainUnaryInterceptor(
                authUnaryInterceptor(
                        map[string]bool{
                                "/api.proto.v1.GophKeeper/DataList":   true,
                                "/api.proto.v1.GophKeeper/DataView":   true,
                                "/api.proto.v1.GophKeeper/DataSave":   true,
                                "/api.proto.v1.GophKeeper/DataDelete": true,
                        },
                        []byte(cfg.JWT.Secret),
                ),
                grpcLogging.UnaryServerInterceptor(logging.InterceptorLogger(log)),
        ))

        srv := grpc.NewServer(opts...)

        h := NewGRPCHandler(sa)

        pb.RegisterGophKeeperServer(srv, h)
        reflection.Register(srv)

        g, ctx := errgroup.WithContext(context.Background())

        g.Go(func() error </span><span class="cov1" title="1">{
                &lt;-ctx.Done()
                srv.GracefulStop()
                return nil
        }</span>)

        <span class="cov1" title="1">g.Go(func() error </span><span class="cov1" title="1">{
                log.Info(fmt.Sprintf("Starting gRPC server at %s, TLS: %t", cfg.GRPCAddress, cfg.TLSConfig.EnableHTTPS))
                return srv.Serve(lis)
        }</span>)

        <span class="cov1" title="1">go func() </span><span class="cov1" title="1">{
                if err := g.Wait(); err != nil </span><span class="cov0" title="0">{
                        log.Error("gRPC server error: " + err.Error())
                }</span>
        }()

        <span class="cov1" title="1">return srv, nil</span>
}

// authUnaryInterceptor returns a gRPC unary server interceptor for JWT authentication.
//
// This interceptor checks if the called method requires authentication. For protected methods,
// it extracts and validates the JWT from the request metadata, verifies the signing method and claims,
// and injects the user ID and JWT into the context for downstream handlers.
//
// Parameters:
//   - protected: Map of gRPC method names that require authentication.
//   - jwtSecret: Secret key used to validate JWT tokens.
//
// Returns:
//   - grpc.UnaryServerInterceptor: The configured authentication interceptor.
func authUnaryInterceptor(protected map[string]bool, jwtSecret []byte) grpc.UnaryServerInterceptor <span class="cov1" title="1">{
        slog.Info("Auth interceptor enabled")

        return func(
                ctx context.Context,
                req interface{},
                info *grpc.UnaryServerInfo,
                handler grpc.UnaryHandler,
        ) (interface{}, error) </span><span class="cov1" title="1">{
                if !protected[info.FullMethod] </span><span class="cov1" title="1">{
                        return handler(ctx, req)
                }</span>

                <span class="cov0" title="0">md, ok := metadata.FromIncomingContext(ctx)
                if !ok </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.Unauthenticated, "missing metadata")
                }</span>

                <span class="cov0" title="0">jwtHeader := md.Get(string(constants.JWT))
                if len(jwtHeader) == 0 || jwtHeader[0] == "" </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.Unauthenticated, "missing jwt")
                }</span>

                <span class="cov0" title="0">tokenStr := jwtHeader[0]

                token, err := jwt.Parse(tokenStr, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                                return nil, errors.New("unexpected signing method")
                        }</span>
                        <span class="cov0" title="0">return jwtSecret, nil</span>
                })

                <span class="cov0" title="0">if err != nil || !token.Valid </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.Unauthenticated, "invalid jwt")
                }</span>

                <span class="cov0" title="0">if claims, ok := token.Claims.(jwt.MapClaims); ok </span><span class="cov0" title="0">{
                        if uidFloat, ok := claims["user_id"].(float64); ok </span><span class="cov0" title="0">{
                                userID := int(uidFloat)
                                ctx = context.WithValue(ctx, constants.UserID, userID)
                        }</span> else<span class="cov0" title="0"> {
                                return nil, status.Error(codes.InvalidArgument, "user_id not found or not a number")
                        }</span>
                }

                <span class="cov0" title="0">ctx = context.WithValue(ctx, constants.JWT, tokenStr)
                return handler(ctx, req)</span>
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Package http provides the HTTP server implementation for the GophKeeper service.
//
// It sets up an HTTP server with gRPC-Gateway for proxying RESTful requests to the gRPC backend,
// configures CORS middleware, and manages TLS support. The package handles server startup,
// graceful shutdown, and integration with application configuration and logging.
package http

import (
        "context"
        "crypto/x509"
        "errors"
        "fmt"
        "net/http"
        "os"
        "time"

        "github.com/apetsko/gophkeeper/config"
        "github.com/apetsko/gophkeeper/pkg/logging"
        pb "github.com/apetsko/gophkeeper/protogen/api/proto/v1"
        "github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
        "github.com/rs/cors"
        "golang.org/x/sync/errgroup"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials"
        "google.golang.org/grpc/credentials/insecure"
        "google.golang.org/grpc/metadata"
)

// RunHTTP starts the HTTP server with gRPC-Gateway and CORS support.
//
// This function configures the HTTP server to proxy requests to the gRPC backend using gRPC-Gateway,
// sets up CORS middleware, and manages TLS if enabled. It listens on the configured address and
// gracefully shuts down the server on context cancellation.
//
// Parameters:
//   - ctx: The context for server lifecycle management.
//   - cfg: Pointer to the application configuration.
//   - log: Logger instance for server logging.
//
// Returns:
//   - *http.Server: The running HTTP server instance.
//   - error: An error if the server fails to start.
func RunHTTP(ctx context.Context, cfg *config.Config, log *logging.Logger) (*http.Server, error) <span class="cov8" title="1">{
        mux := runtime.NewServeMux(
                runtime.WithMetadata(func(ctx context.Context, req *http.Request) metadata.MD </span><span class="cov8" title="1">{
                        md := metadata.New(nil)
                        if auth := req.Header.Get("jwt"); auth != "" </span><span class="cov0" title="0">{
                                md.Set("jwt", auth)
                        }</span>
                        <span class="cov8" title="1">return md</span>
                }),
        )

        <span class="cov8" title="1">c := cors.New(cors.Options{
                AllowedOrigins:   []string{"*"},
                AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
                AllowedHeaders:   []string{"*"},
                AllowCredentials: true,
        })
        handler := c.Handler(mux)

        var opts []grpc.DialOption

        if cfg.TLSConfig.EnableHTTPS </span><span class="cov0" title="0">{
                // Загрузить сертификат CA (корневой сертификат), которым подписан сервер gRPC,
                // чтобы grpc-gateway доверял этому соединению
                certPool := x509.NewCertPool()
                caCert, err := os.ReadFile(cfg.TLSConfig.CertPath)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("failed to read CA cert: %v", err)
                }</span>
                <span class="cov0" title="0">if !certPool.AppendCertsFromPEM(caCert) </span><span class="cov0" title="0">{
                        log.Fatalf("failed to append CA cert")
                }</span>
                <span class="cov0" title="0">creds := credentials.NewClientTLSFromCert(certPool, "")
                opts = append(opts, grpc.WithTransportCredentials(creds))</span>
        } else<span class="cov8" title="1"> {
                opts = append(opts, grpc.WithTransportCredentials(insecure.NewCredentials()))
        }</span>

        <span class="cov8" title="1">if err := pb.RegisterGophKeeperHandlerFromEndpoint(ctx, mux, cfg.GRPCAddress, opts); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to register gRPC-Gateway: %v", err)
        }</span>

        <span class="cov8" title="1">srv := &amp;http.Server{
                Addr:              cfg.HTTPAddress,
                Handler:           handler,
                ReadHeaderTimeout: 3 * time.Second,
        }

        g, ctx := errgroup.WithContext(context.Background())

        g.Go(func() error </span><span class="cov8" title="1">{
                &lt;-ctx.Done()
                five := 5 * time.Second
                shutdownCtx, cancel := context.WithTimeout(context.Background(), five)
                defer cancel()
                return srv.Shutdown(shutdownCtx)
        }</span>)

        <span class="cov8" title="1">g.Go(func() error </span><span class="cov8" title="1">{
                log.Info(fmt.Sprintf("Starting HTTP server at %s, TLS: %t", srv.Addr, cfg.TLSConfig.EnableHTTPS))
                if cfg.TLSConfig.EnableHTTPS </span><span class="cov0" title="0">{
                        return srv.ListenAndServeTLS(cfg.TLSConfig.CertPath, cfg.TLSConfig.KeyPath)
                }</span>
                <span class="cov8" title="1">return srv.ListenAndServe()</span>
        })

        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                if err := g.Wait(); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                        log.Error("HTTP server error: " + err.Error())
                }</span>
        }()

        <span class="cov8" title="1">return srv, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Package storage provides PostgreSQL-backed storage implementation for GophKeeper.
//
// This package defines the Storage type and related interfaces for managing users, master keys,
// and user data in a PostgreSQL database. It handles database migrations, connection pooling,
// and CRUD operations for application data.
package storage

import (
        "context"
        "database/sql"
        "embed"
        "errors"
        "fmt"
        "log"
        "time"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
        "github.com/pressly/goose/v3"

        "github.com/jackc/pgx/v5/pgxpool"
        _ "github.com/jackc/pgx/v5/stdlib"

        "github.com/apetsko/gophkeeper/models"
)

// PgxPoolIface abstracts a subset of pgxpool.Pool methods for database operations.
//
// This interface allows for easier testing and mocking of database interactions.
type PgxPoolIface interface {
        QueryRow(context.Context, string, ...interface{}) pgx.Row
        Query(context.Context, string, ...interface{}) (pgx.Rows, error)
        Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
        Begin(context.Context) (pgx.Tx, error)
        Close()
        Ping(context.Context) error
}

// migrations embeds SQL migration files for database schema management.
//
//go:embed migrations/*.sql
var migrations embed.FS

// Storage implements the IStorage interface using a PostgreSQL backend.
//
// It provides methods for user management, master key storage, and user data operations.
type Storage struct {
        DB PgxPoolIface
}

// migrate applies database migrations using goose and the embedded migration files.
//
// Parameters:
//   - conn: PostgreSQL connection string.
//
// Returns:
//   - error: An error if migrations fail, otherwise nil.
func migrate(conn string) error <span class="cov8" title="17">{
        goose.SetBaseFS(migrations)

        var db *sql.DB
        var err error
        for i := 0; i &lt; 10; i++ </span><span class="cov10" title="26">{
                db, err = sql.Open("pgx", conn)
                if err == nil </span><span class="cov10" title="26">{
                        err = db.Ping()
                        if err == nil </span><span class="cov8" title="16">{
                                break</span> // подключились!
                        }
                }
                <span class="cov7" title="10">log.Printf("waiting for DB... (%d/10)", i+1)
                time.Sleep(2 * time.Second)</span>
        }
        <span class="cov8" title="17">if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("goose: failed to connect to DB after retries: %w", err)
        }</span>
        <span class="cov8" title="16">defer db.Close()

        err = goose.Up(db, "migrations")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("goose: migration failed: %w", err)
        }</span>
        <span class="cov8" title="16">return nil</span>
}

// NewPostgresClient creates a new Storage instance with a PostgreSQL connection pool.
//
// It applies database migrations before establishing the connection.
//
// Parameters:
//   - conn: PostgreSQL connection string.
//
// Returns:
//   - IStorage: The initialized storage instance.
//   - error: An error if migrations or connection fail.
func NewPostgresClient(conn string) (IStorage, error) <span class="cov8" title="17">{
        if err := migrate(conn); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="16">ctx := context.Background()
        pool, err := pgxpool.New(ctx, conn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to connect to database: %w", err)
        }</span>

        <span class="cov8" title="16">return &amp;Storage{DB: pool}, nil</span>
}

// Close closes the underlying database connection pool.
//
// Returns:
//   - error: Always nil.
func (p *Storage) Close() error <span class="cov8" title="16">{
        p.DB.Close()
        return nil
}</span>

// AddUser inserts a new user into the database.
//
// Parameters:
//   - ctx: Context for the operation.
//   - u: Pointer to the UserEntry to add.
//
// Returns:
//   - int: The new user's ID.
//   - error: An error if the user exists or insertion fails.
func (p *Storage) AddUser(ctx context.Context, u *models.UserEntry) (int, error) <span class="cov5" title="5">{
        const insertUser = `
        INSERT INTO users (username, password_hash, created_at, updated_at)
        VALUES ($1, $2, NOW(), NOW())
        ON CONFLICT (username) DO NOTHING
        RETURNING id;
    `

        var id int
        err := p.DB.QueryRow(ctx, insertUser, u.Username, u.PasswordHash).Scan(&amp;id)

        switch </span>{
        case err == nil:<span class="cov4" title="3">
                return id, nil</span> // Successfully created
        case errors.Is(err, pgx.ErrNoRows):<span class="cov1" title="1">
                return 0, models.ErrUserExists</span> // Username conflict
        default:<span class="cov1" title="1">
                return 0, fmt.Errorf("failed to insert user: %w", err)</span>
        }
}

// GetUser retrieves a user by username.
//
// Parameters:
//   - ctx: Context for the operation.
//   - username: Username to search for.
//
// Returns:
//   - *models.UserEntry: The found user entry.
//   - error: An error if not found or query fails.
func (p *Storage) GetUser(ctx context.Context, username string) (*models.UserEntry, error) <span class="cov4" title="3">{
        const getUser = `
                SELECT id, username, password_hash FROM users
                WHERE username = $1;
        `

        var u models.UserEntry

        err := p.DB.QueryRow(ctx, getUser, username).Scan(&amp;u.ID, &amp;u.Username, &amp;u.PasswordHash)
        if err != nil </span><span class="cov2" title="2">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov1" title="1">{
                        return nil, models.ErrUserNotFound
                }</span>
                <span class="cov1" title="1">return nil, err</span>
        }
        <span class="cov1" title="1">return &amp;u, nil</span>
}

// SaveMasterKey stores an encrypted master key for a user.
//
// Parameters:
//   - ctx: Context for the operation.
//   - userID: User ID.
//   - encryptedMK: Encrypted master key bytes.
//   - nonce: Nonce used for encryption.
//
// Returns:
//   - int: The new record's ID.
//   - error: An error if the operation fails.
func (p *Storage) SaveMasterKey(
        ctx context.Context,
        userID int,
        encryptedMK []byte,
        nonce []byte,
) (int, error) <span class="cov2" title="2">{
        const insertSQL = `
        INSERT INTO user_keys (user_id, encrypted_master_key, nonce) 
        VALUES ($1, $2, $3)
        RETURNING id;
    `

        var id int

        err := p.DB.QueryRow(ctx, insertSQL, userID, encryptedMK, nonce).Scan(&amp;id)
        if err != nil </span><span class="cov1" title="1">{
                return 0, fmt.Errorf("failed to save master key: %w", err)
        }</span>

        <span class="cov1" title="1">return id, err</span>
}

// GetMasterKey retrieves the encrypted master key for a user.
//
// Parameters:
//   - ctx: Context for the operation.
//   - userID: User ID.
//
// Returns:
//   - *models.EncryptedMK: The encrypted master key and nonce.
//   - error: An error if not found or query fails.
func (p *Storage) GetMasterKey(ctx context.Context, userID int) (*models.EncryptedMK, error) <span class="cov4" title="3">{
        const selectSQL = `
        SELECT encrypted_master_key, nonce FROM user_keys 
        WHERE user_id = $1;
    `

        var encryptedMK models.EncryptedMK
        err := p.DB.QueryRow(ctx, selectSQL, userID).Scan(&amp;encryptedMK.EncryptedMK, &amp;encryptedMK.Nonce)
        if err != nil </span><span class="cov2" title="2">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov1" title="1">{
                        return nil, models.ErrMasterKeyNotFound
                }</span>
                <span class="cov1" title="1">return nil, err</span>
        }

        <span class="cov1" title="1">return &amp;encryptedMK, err</span>
}

// SaveUserData stores encrypted user data in the database.
//
// Parameters:
//   - ctx: Context for the operation.
//   - userData: Pointer to the DBUserData to store.
//
// Returns:
//   - int: The new record's ID.
//   - error: An error if the operation fails.
func (p *Storage) SaveUserData(ctx context.Context, userData *models.DBUserData) (int, error) <span class="cov1" title="1">{
        const insertSQL = `
        INSERT INTO user_data (user_id, type, minio_object_id, encrypted_data, data_nonce, encrypted_dek, dek_nonce, meta) 
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
        RETURNING id;
    `

        var id int

        err := p.DB.QueryRow(
                ctx,
                insertSQL,
                userData.UserID,
                userData.Type,
                userData.MinioObjectID,
                userData.EncryptedData,
                userData.DataNonce,
                userData.EncryptedDek,
                userData.DekNonce,
                userData.Meta,
        ).Scan(&amp;id)
        if err != nil </span><span class="cov1" title="1">{
                return 0, fmt.Errorf("failed to save user data: %w", err)
        }</span>

        <span class="cov0" title="0">return id, err</span>
}

// GetUserData retrieves a user data record by its ID.
//
// Parameters:
//   - ctx: Context for the operation.
//   - userDataID: ID of the user data record.
//
// Returns:
//   - *models.DBUserData: The user data record.
//   - error: An error if not found or query fails.
func (p *Storage) GetUserData(ctx context.Context, userDataID int) (*models.DBUserData, error) <span class="cov2" title="2">{
        const selectSQL = `
        SELECT user_id, 
               type,
               minio_object_id,
               encrypted_data,
               data_nonce,
               encrypted_dek,
               dek_nonce,
               meta FROM user_data 
        WHERE id = $1;
    `

        var userData models.DBUserData

        err := p.DB.QueryRow(ctx, selectSQL, userDataID).Scan(
                &amp;userData.UserID,
                &amp;userData.Type,
                &amp;userData.MinioObjectID,
                &amp;userData.EncryptedData,
                &amp;userData.DataNonce,
                &amp;userData.EncryptedDek,
                &amp;userData.DekNonce,
                &amp;userData.Meta,
        )
        if err != nil </span><span class="cov2" title="2">{
                return &amp;userData, fmt.Errorf("failed to get user data: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;userData, err</span>
}

// GetUserDataList returns a list of user data items for a given user.
//
// Parameters:
//   - ctx: Context for the operation.
//   - userID: User ID.
//
// Returns:
//   - []models.UserDataListItem: List of user data items.
//   - error: An error if the query fails.
func (p *Storage) GetUserDataList(ctx context.Context, userID int) ([]models.UserDataListItem, error) <span class="cov1" title="1">{
        const selectSQL = `
        SELECT id,
               user_id, 
               type,
               meta,
               created_at
        FROM user_data 
        WHERE user_id = $1
        ORDER BY id DESC;
    `

        rows, err := p.DB.Query(ctx, selectSQL, userID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to query user data list: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var result []models.UserDataListItem
        for rows.Next() </span><span class="cov0" title="0">{
                var data models.UserDataListItem
                err := rows.Scan(
                        &amp;data.ID,
                        &amp;data.UserID,
                        &amp;data.Type,
                        &amp;data.Meta,
                        &amp;data.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan row: %w", err)
                }</span>
                <span class="cov0" title="0">result = append(result, data)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("rows error: %w", err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// DeleteUserData deletes a user data record by its ID.
//
// Parameters:
//   - ctx: Context for the operation.
//   - userDataID: ID of the user data record to delete.
//
// Returns:
//   - error: An error if not found or deletion fails.
func (p *Storage) DeleteUserData(ctx context.Context, userDataID int) error <span class="cov2" title="2">{
        const deleteSQL = `
        DELETE FROM user_data 
        WHERE id = $1
        RETURNING id;
    `

        var deletedID int
        err := p.DB.QueryRow(ctx, deleteSQL, userDataID).Scan(&amp;deletedID)
        if err != nil </span><span class="cov2" title="2">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov1" title="1">{
                        return fmt.Errorf("user data with ID %d not found", userDataID)
                }</span>
                <span class="cov1" title="1">return fmt.Errorf("failed to delete user data: %w", err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Package storage provides S3-compatible object storage integration for GophKeeper.
//
// This package implements an S3 client using MinIO for uploading and retrieving encrypted user files.
package storage

import (
        "bytes"
        "context"
        "fmt"
        "io"
        "log"
        "time"

        "github.com/minio/minio-go/v7"
        "github.com/minio/minio-go/v7/pkg/credentials"

        "github.com/apetsko/gophkeeper/config"
        "github.com/apetsko/gophkeeper/models"
)

// S3Client defines the interface for S3-compatible object storage operations.
//
// It abstracts file upload and retrieval for easier testing and mocking.
type S3Client interface {
        Upload(ctx context.Context, data []byte, s3UploadData *models.S3UploadData) (*minio.UploadInfo, error)
        GetObject(ctx context.Context, objectName string) ([]byte, *minio.ObjectInfo, error)
}

// S3 implements the S3Client interface using a MinIO client.
//
// It provides methods to upload and retrieve objects from the configured bucket.
type S3 struct {
        MinioClient *minio.Client
        MinioBucket string
}

// NewS3Client initializes a new S3 client with the given configuration.
//
// It connects to the MinIO server, checks for the existence of the bucket, and creates it if necessary.
//
// Parameters:
//   - ctx: Context for the operation.
//   - cfg: S3Config with endpoint, credentials, and bucket name.
//
// Returns:
//   - *S3: The initialized S3 client.
//   - error: An error if initialization fails.
func NewS3Client(ctx context.Context, cfg config.S3Config) (*S3, error) <span class="cov1" title="1">{
        var err error

        minioClient, err := minio.New(cfg.Endpoint, &amp;minio.Options{
                Creds:  credentials.NewStaticV4(cfg.AccessKey, cfg.SecretKey, ""),
                Secure: false,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error init minio client: %v", err)
        }</span>

        <span class="cov1" title="1">log.Printf("Checking if bucket %s exists...", cfg.Bucket)
        bucketExists, err := minioClient.BucketExists(ctx, cfg.Bucket)
        log.Printf("BucketExists call returned: %v, err: %v", bucketExists, err)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check bucket existence: %v", err)
        }</span>

        <span class="cov1" title="1">if !bucketExists </span><span class="cov1" title="1">{
                if errMakeBucket := minioClient.MakeBucket(ctx, cfg.Bucket, minio.MakeBucketOptions{}); errMakeBucket != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create bucket: %v", errMakeBucket)
                }</span>
        }

        <span class="cov1" title="1">return &amp;S3{
                MinioClient: minioClient,
                MinioBucket: cfg.Bucket,
        }, err</span>
}

// Upload uploads data to the S3 bucket with the specified metadata.
//
// Parameters:
//   - ctx: Context for the operation.
//   - data: File data to upload.
//   - s3UploadData: Metadata and object information.
//
// Returns:
//   - *minio.UploadInfo: Information about the uploaded object.
//   - error: An error if the upload fails.
func (s *S3) Upload(
        ctx context.Context,
        data []byte,
        s3UploadData *models.S3UploadData,
) (*minio.UploadInfo, error) <span class="cov1" title="1">{
        info, errPutObject := s.MinioClient.PutObject(
                ctx,
                s.MinioBucket,
                s3UploadData.ObjectName,
                bytes.NewReader(data),
                int64(len(data)),
                minio.PutObjectOptions{
                        ContentType: s3UploadData.FileType,
                        UserMetadata: map[string]string{
                                "original-name": s3UploadData.FileName,
                                "meta-content":  s3UploadData.MetaContent,
                                "upload-time":   time.Now().Format(time.RFC3339),
                                "is-encrypted":  "true",
                        },
                },
        )

        if errPutObject != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to upload file to MinIO: %v", errPutObject)
        }</span>

        <span class="cov1" title="1">return &amp;info, nil</span>
}

// GetObject retrieves an object from the S3 bucket by its name.
//
// Parameters:
//   - ctx: Context for the operation.
//   - objectName: Name of the object to retrieve.
//
// Returns:
//   - []byte: The object data.
//   - *minio.ObjectInfo: Metadata about the object.
//   - error: An error if retrieval fails.
func (s *S3) GetObject(
        ctx context.Context,
        objectName string,
) ([]byte, *minio.ObjectInfo, error) <span class="cov10" title="2">{
        object, err := s.MinioClient.GetObject(
                ctx,
                s.MinioBucket,
                objectName,
                minio.GetObjectOptions{},
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to get object from MinIO: %v", err)
        }</span>
        <span class="cov10" title="2">defer object.Close()

        objectInfo, err := object.Stat()
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, fmt.Errorf("failed to get object info: %v", err)
        }</span>

        <span class="cov1" title="1">data := make([]byte, objectInfo.Size)
        _, err = io.ReadFull(object, data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to read object data: %v", err)
        }</span>

        <span class="cov1" title="1">return data, &amp;objectInfo, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Package jwt offers utilities for generating and handling JSON Web Tokens (JWT)
// for authentication and authorization.
package jwt

import (
        "time"

        "github.com/golang-jwt/jwt/v5"
)

// GenerateJWT creates a signed JWT token for the given user ID and username.
//
// The token uses HS256 signing and includes user ID, username, and issued-at claims.
//
// Returns the signed JWT string or an error if signing fails.
func GenerateJWT(userID int, username, jwtSecret string) (string, error) <span class="cov10" title="5">{
        claims := jwt.MapClaims{
                "user_id": userID,
                "name":    username,
                "iat":     time.Now().Unix(),
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

        return token.SignedString([]byte(jwtSecret))
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">// Package logging provides structured logging utilities and wrappers around slog,
// including convenience methods and gRPC middleware integration.
package logging

import (
        "context"
        "fmt"
        "log/slog"
        "os"
        "path/filepath"
        "time"

        grpc_logging "github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/logging"
)

// GenerateJWT creates a signed JWT token for the given user ID and username.
//
// The token uses HS256 signing and includes user ID, username, and issued-at claims.
//
// Returns the signed JWT string or an error if signing fails.
func LogHandler(level slog.Level) *slog.Logger <span class="cov5" title="9">{
        handler := slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{
                Level:     level,
                AddSource: true,
                ReplaceAttr: func(groups []string, a slog.Attr) slog.Attr </span><span class="cov10" title="96">{
                        if a.Key == slog.TimeKey </span><span class="cov6" title="18">{
                                if t, ok := a.Value.Any().(time.Time); ok </span><span class="cov6" title="18">{
                                        a = slog.Attr{
                                                Key:   a.Key,
                                                Value: slog.StringValue(t.Format("2006-01-02T15:04:05.000Z07:00")),
                                        }
                                }</span>
                        }

                        <span class="cov10" title="96">if a.Key == slog.SourceKey </span><span class="cov6" title="18">{
                                src, ok := a.Value.Any().(*slog.Source)
                                if ok </span><span class="cov6" title="18">{
                                        link := fmt.Sprintf("file://%s:%d", src.File, src.Line)
                                        a = slog.Attr{
                                                Key:   filepath.Base(src.Function),
                                                Value: slog.StringValue(link),
                                        }
                                }</span>
                        }
                        <span class="cov10" title="96">return a</span>
                },
        })
        <span class="cov5" title="9">return slog.New(handler)</span>
}

// Logger wraps slog.Logger and provides convenience methods for formatted logging.
type Logger struct {
        *slog.Logger
}

// NewLogger creates a new Logger with the specified log level.
func NewLogger(level slog.Level) *Logger <span class="cov5" title="9">{
        base := LogHandler(level)
        return &amp;Logger{Logger: base}
}</span>

// Debugf logs a debug-level message with formatting.
func (l *Logger) Debugf(format string, args ...any) <span class="cov1" title="1">{
        l.Debug(fmt.Sprintf(format, args...))
}</span>

// Infof logs an info-level message with formatting.
func (l *Logger) Infof(format string, args ...any) <span class="cov1" title="1">{
        l.Info(fmt.Sprintf(format, args...))
}</span>

// Warnf logs a warning-level message with formatting.
func (l *Logger) Warnf(format string, args ...any) <span class="cov1" title="1">{
        l.Warn(fmt.Sprintf(format, args...))
}</span>

// Errorf logs an error-level message with formatting.
func (l *Logger) Errorf(format string, args ...any) <span class="cov1" title="1">{
        l.Error(fmt.Sprintf(format, args...))
}</span>

// Fatal logs an error-level message and exits the application.
func (l *Logger) Fatal(msg string) <span class="cov1" title="1">{
        l.Log(context.Background(), slog.LevelError, msg)
        os.Exit(1)
}</span>

// Fatalf logs a formatted error-level message and exits the application.
func (l *Logger) Fatalf(format string, args ...any) <span class="cov1" title="1">{
        l.Log(context.Background(), slog.LevelError, fmt.Sprintf(format, args...))
        os.Exit(1)
}</span>

// InterceptorLogger returns a grpc_logging.Logger compatible with slog for gRPC middleware.
func InterceptorLogger(l *Logger) grpc_logging.Logger <span class="cov2" title="2">{
        return grpc_logging.LoggerFunc(func(ctx context.Context, lvl grpc_logging.Level, msg string, fields ...any) </span><span class="cov4" title="6">{
                args := make([]any, 0, len(fields))

                for i := 0; i &lt; len(fields); i += 2 </span><span class="cov7" title="21">{
                        key := fields[i]
                        value := fields[i+1]
                        args = append(args, key, value)
                }</span>

                <span class="cov4" title="6">switch lvl </span>{
                case grpc_logging.LevelDebug:<span class="cov1" title="1">
                        l.Debug(msg, args...)</span>
                case grpc_logging.LevelInfo:<span class="cov3" title="4">
                        l.Info(msg, args...)</span>
                case grpc_logging.LevelWarn:<span class="cov0" title="0">
                        slog.Warn(msg, args...)</span>
                case grpc_logging.LevelError:<span class="cov1" title="1">
                        l.Error(msg, args...)</span>
                default:<span class="cov0" title="0">
                        panic(fmt.Sprintf("unknown level %v", lvl))</span>
                }
        })
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Package password provides password hashing and verification utilities using bcrypt.
package password

import "golang.org/x/crypto/bcrypt"

const passwordCost = 14

// HashPassword hashes the given password using bcrypt with a predefined cost.
//
// Returns the hashed password as a string or an error if hashing fails.
func HashPassword(password string) (string, error) <span class="cov10" title="5">{
        bytes, err := bcrypt.GenerateFromPassword([]byte(password), passwordCost)
        return string(bytes), err
}</span>

// CheckPasswordHash compares a bcrypt hashed password with its possible plaintext equivalent.
//
// Returns true if the password matches the hash, false otherwise.
func CheckPasswordHash(password, hash string) bool <span class="cov10" title="5">{
        err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
        return err == nil
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">// Package version contains build-time version information for the application.
package version

import (
        "fmt"
)

// Version is the current application version.
var Version = ""

// BuildDate is the date when the application was built.
var BuildTime = ""

// CommitHash is the git commit hash of the build.
var CommitHash = ""

func PrintVersion() <span class="cov0" title="0">{
        fmt.Printf("Version: %s\nBuild time: %s\nCommitHash: %s\n", Version, BuildTime, CommitHash)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">// Package utils contains helper functions for password hashing, ID generation, and struct validation.
package utils

import (
        "crypto/sha256"
        "encoding/base64"

        "github.com/go-playground/validator/v10"
        "golang.org/x/crypto/bcrypt"
)

// PasswordHasher defines the interface for password hashing implementations.
//
// Implementations should provide a method to hash a plaintext password.
type PasswordHasher interface {
        // HashPassword hashes the given plaintext password and returns the hash or an error.
        HashPassword(password string) ([]byte, error)
}

// BcryptHasher implements the PasswordHasher interface using bcrypt.
type BcryptHasher struct{}

// HashPassword hashes the given password using bcrypt.
//
// Returns the hashed password as a byte slice or an error if hashing fails.
func (b *BcryptHasher) HashPassword(password string) ([]byte, error) <span class="cov1" title="1">{
        return bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
}</span>

// ComparePassword compares a bcrypt hashed password with its possible plaintext equivalent.
//
// Returns true if the password matches the hash, false otherwise.
func ComparePassword(hash, password string) bool <span class="cov4" title="2">{
        return bcrypt.CompareHashAndPassword([]byte(hash), []byte(password)) == nil
}</span>

// HashPassword hashes the given password using bcrypt with the default cost.
//
// Returns the hashed password as a byte slice or an error if hashing fails.
func HashPassword(password string) ([]byte, error) <span class="cov4" title="2">{
        return bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
}</span>

// GenerateID generates a base64-encoded, URL-safe ID of the specified length from the SHA-256 hash of the input string.
//
// Parameters:
//   - s: The input string to hash.
//   - length: The desired length of the resulting ID.
//
// Returns the generated ID as a string.
func GenerateID(s string, length int) (id string) <span class="cov4" title="2">{
        hash := sha256.Sum256([]byte(s))
        id = base64.RawURLEncoding.EncodeToString(hash[:length])[:length]
        return
}</span>

// ValidateStruct validates a struct using the go-playground/validator package.
//
// Returns an error if validation fails, or nil if the struct is valid.
func ValidateStruct(a any) error <span class="cov10" title="7">{
        return validator.New().Struct(a)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
